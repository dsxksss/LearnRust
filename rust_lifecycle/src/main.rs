/*
Rust 生命周期机制是与所有权机制同等重要的资源管理机制。
之所以引入这个概念主要是应对复杂类型系统中资源管理的问题。
引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算。

rust的每个引用都有自己的生命周期
生命周期:引用保持有效的作用域
大多数情况:生命周期是隐式的、可被推断的
当引用的生命周期可能以不同的方式互相关联是:可以手动标注生命周期。
*/

/*
生命周期-避免垂直引用(dangling reference)
生命周期的主要目标:避免垂直引用(dangling reference)
例子:
fn main(){
    {
        let r;
        {
            let x=5;
            r=&x; 这里会报错
        }
        println!("r: {}",r);
    }
}
*/

/*
函数中的泛型生命周期
例子:
fn main(){
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(),string2);
    println!("The longest string is {}",result);
}

fn longest<'a>(x:&'a str,y:&'a str)->&'a str{
    if x.len() > y.len() {
        x
    }else{
        y
    }
}
*/

/*
生命周期标注语法
生命周期的标注不会改变引用的生命周期长度
当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用
生命周期的标注:描述了多个引用的生命周期间的关系，但不影响生命周期

生命周期参数名语法:
-以'开头
-通常全小写且非常短
-很多人使用'a

生命周期标注的位置:
-在引用的&符号后
-使用空格将标注和引用类型分开
例子:
&i32   一个引用
&'a i32   带有显式生命周期的引用
&'a mut i32  带有显式生命周期的可变引用
请记住:单给生命周期标注本身没有意义(在泛型函数签名中情况除外)
*/

/*
函数签名中的生命周期标注
泛型生命周期参数声明在:函数名和参数列表之间的<>里
例子:fn longest<'a>(x:&'a str,y:&'a str)->&'a str{}
这里表示x和y这两个引用的生命周期时长、返回引用的生命周期时长
不能短于此longest函数的生命周期

生命周期'a的实际生命周期是:x和y两个生命周期中较小的那个
*/
fn main() {
    println!("Hello, world!");
}
