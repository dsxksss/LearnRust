/*
基本类型
int(i8,i16,i32<默认>,i64,i128):整数类型,包括负数,
+int(u8,u16,u32<默认>,u64,u128):正整数类型,因为不包含负数,所以可以包含更多正整数
float(f32<默认>,f64):浮点类型,数字越大精度越高,因此小数点位数也要多
bool(true,false):布尔类型
小知识:有时候可以看见带下划线的数字,那么做的意义是可以快速方便查看此数字的位数

****变量的创建语法 <let> <mut可选> <变量名>:<变量类型 可忽略,因为会自动推导> = <变量值>
--变量的特性:
1、必须使用mut关键字表示此变量内容可被改变
2、在rust语言里，每个变量内容默认都是不可变的
3、就算加了mut关键字也不能改变它的根类型只允许改变相同类型的值
4、创建的同时可以省略类型标注
5、可以使用as关键字表示强制转换
****常量的创建语法 <const> <变量名>:<变量类型 不可忽略> = <常量值>
--常量的特性：
1、不可以使用mut,常量永远都是不可变的
2、声明常量使用const关键字,它的类型必须被标注
3、常量可以在任何作用域内进行声明,包括全局作用域
4、常量只可以绑定到常量表达式,无法绑定到函数的调用结果或只能在运行是才能计算出的值
5、在程序运行期间,常量在其声明的作用域内一直有效
6、命名规范是:全使用大写字母,每个单词之间用下划线分开

rust特性：
1、Shadowing(隐藏)
·可以使用相同的名字声明新的变量,新的变量就会shadow(隐藏)之前声明过的同名变量,在后续代码中使用的将会使用新创建的变量
·shadow和把变量标记为mut的变量是不一样的,shadow可以赋予其他类型,仅使用mut的变量则不行;
·如果不适用let关键字,那么重新给非mut的变量赋值会导致编译错误
·使用let声明的同名新变量也是不可变的,但是创建时可以赋值新的类型
*/
fn rust_type1() {
    let a = 12;
    let mut b = 0; //这里的as表示强制转换成了i32类型的变量
    println!("b原来的值{}", b);
    b = 30 as i64;
    let c: bool = true;
    const CONST_VAR: u32 = 500_000;
    println!(
        "a={}\tb={}\t使用隐藏特性前的c={}\tCONST_VAR={}\t",
        a, b, c, CONST_VAR
    );

    let c: u32 = 50;
    println!("使用隐藏特性后的c={}", c);
    println!("你好");
}

//特殊类型(元组,结构,数组,内存)
fn rust_type2() {
    //元组的定义语法 <let> <mut可选> <元组名>:<(元组元素的类型 可忽略)> = <(元组值)>
    //元组限制再次增加或减少个数,但是允许改变原有内容(需加mut关键字)
    let _yz: (i32, f64, bool) = (28, 1.64, true);
}

fn main() {
    rust_type1();
    rust_type2();
}
